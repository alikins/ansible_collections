# Ansible module: ansible.module_uri


Interacts with webservices

## Description

Interacts with HTTP and HTTPS web services and supports Digest, Basic and WSSE HTTP authentication mechanisms.
For Windows targets, use the M(win_uri) module instead.

## Requirements

TODO

## Arguments

``` json
{
    "body": "{'description': ["The body of the http request/response to the web service. If C(body_format) is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON. If C(body_format) is set to 'form-urlencoded' it will convert a dictionary or list of tuples into an 'application/x-www-form-urlencoded' string. (Added in v2.7)"]}",
    "body_format": "{'description': ['The serialization format of the body. When set to C(json) or C(form-urlencoded), encodes the body argument, if needed, and automatically sets the Content-Type header accordingly. As of C(2.3) it is possible to override the `Content-Type` header, when set to C(json) or C(form-urlencoded) via the I(headers) option.'], 'choices': ['form-urlencoded', 'json', 'raw'], 'default': 'raw', 'version_added': '2.0'}",
    "client_cert": "{'description': ['PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, I(client_key) is not required'], 'version_added': '2.4'}",
    "client_key": "{'description': ['PEM formatted file that contains your private key to be used for SSL client authentication. If I(client_cert) contains both the certificate and key, this option is not required.'], 'version_added': '2.4'}",
    "creates": "{'description': ['A filename, when it already exists, this step will not be run.']}",
    "dest": "{'description': ['A path of where to download the file to (if desired). If I(dest) is a directory, the basename of the file on the remote server will be used.']}",
    "follow_redirects": "{'description': ['Whether or not the URI module should follow redirects. C(all) will follow all redirects. C(safe) will follow only "safe" redirects, where "safe" means that the client is only doing a GET or HEAD on the URI to which it is being redirected. C(none) will not follow any redirects. Note that C(yes) and C(no) choices are accepted for backwards compatibility, where C(yes) is the equivalent of C(all) and C(no) is the equivalent of C(safe). C(yes) and C(no) are deprecated and will be removed in some future version of Ansible.'], 'choices': ['all', 'none', 'safe'], 'default': 'safe'}",
    "force_basic_auth": "{'description': ['The library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request.'], 'type': 'bool', 'default': False}",
    "HEADER_": "{'description': ['Any parameter starting with "HEADER_" is a sent with your request as a header. For example, HEADER_Content-Type="application/json" would send the header "Content-Type" along with your request with a value of "application/json". This option is deprecated as of C(2.1) and will be removed in Ansible-2.9. Use I(headers) instead.']}",
    "headers": "{'description': ['Add custom HTTP headers to a request in the format of a YAML hash. As of C(2.3) supplying C(Content-Type) here will override the header generated by supplying C(json) or C(form-urlencoded) for I(body_format).'], 'version_added': '2.1'}",
    "method": "{'description': ['The HTTP method of the request or response. It MUST be uppercase.'], 'choices': ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'REFRESH', 'TRACE'], 'default': 'GET'}",
    "others": "{'description': ['All arguments accepted by the M(file) module also work here']}",
    "password": "{'description': ['A password for the module to use for Digest, Basic or WSSE authentication.']}",
    "remote_src": "{'description': ['If C(no), the module will search for src on originating/master machine, if C(yes) the module will use the C(src) path on the remote/target machine.'], 'type': 'bool', 'default': False, 'version_added': '2.7'}",
    "removes": "{'description': ['A filename, when it does not exist, this step will not be run.']}",
    "return_content": "{'description': ['Whether or not to return the body of the response as a "content" key in the dictionary result. If the reported Content-type is "application/json", then the JSON is additionally loaded into a key called C(json) in the dictionary results.'], 'type': 'bool', 'default': False}",
    "src": "{'description': ['Path to file to be submitted to the remote server. Cannot be used with I(body).'], 'version_added': '2.7'}",
    "status_code": "{'description': ['A list of valid, numeric, HTTP status codes that signifies success of the request.'], 'default': 200}",
    "timeout": "{'description': ['The socket level timeout in seconds'], 'default': 30}",
    "url": "{'description': ['HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path'], 'required': True}",
    "user": "{'description': ['A username for the module to use for Digest, Basic or WSSE authentication.']}",
    "validate_certs": "{'description': ['If C(no), SSL certificates will not be validated.  This should only set to C(no) used on personally controlled sites using self-signed certificates.  Prior to 1.9.2 the code defaulted to C(no).'], 'type': 'bool', 'default': True, 'version_added': '1.9.2'}",
}
```

## Examples


``` yaml

- name: Check that you can connect (GET) to a page and it returns a status 200
  uri:
    url: http://www.example.com

# Check that a page returns a status 200 and fail if the word AWESOME is not
# in the page contents.
- uri:
    url: http://www.example.com
    return_content: yes
  register: this
  failed_when: "'AWESOME' not in this.content"

- name: Create a JIRA issue
  uri:
    url: https://your.jira.example.com/rest/api/2/issue/
    method: POST
    user: your_username
    password: your_pass
    body: "{{ lookup('file','issue.json') }}"
    force_basic_auth: yes
    status_code: 201
    body_format: json

# Login to a form based webpage, then use the returned cookie to
# access the app in later tasks

- uri:
    url: https://your.form.based.auth.example.com/index.php
    method: POST
    body_format: form-urlencoded
    body:
      name: your_username
      password: your_password
      enter: Sign in
    status_code: 302
  register: login

# Same, but now using a list of tuples
- uri:
    url: https://your.form.based.auth.example.com/index.php
    method: POST
    body_format: form-urlencoded
    body:
    - [ name, your_username ]
    - [ password, your_password ]
    - [ enter, Sign in ]
    status_code: 302
  register: login

- uri:
    url: https://your.form.based.auth.example.com/dashboard.php
    method: GET
    return_content: yes
    headers:
      Cookie: "{{ login.set_cookie }}"

- name: Queue build of a project in Jenkins
  uri:
    url: http://{{ jenkins.host }}/job/{{ jenkins.job }}/build?token={{ jenkins.token }}
    method: GET
    user: "{{ jenkins.user }}"
    password: "{{ jenkins.password }}"
    force_basic_auth: yes
    status_code: 201

- name: POST from contents of local file
  uri:
    url: "https://httpbin.org/post"
    method: POST
    src: file.json

- name: POST from contents of remote file
  uri:
    url: "https://httpbin.org/post"
    method: POST
    src: /path/to/my/file.json
    remote_src: true

```

## License

TODO

## Author Information
  - ['Romeo Theriault (@romeotheriault)']
